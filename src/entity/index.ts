import Point from "@mapbox/point-geometry";
import { Canvas } from "../canvas";

export type EntityId = number;

export type EntityName = "Merger" | "Splitter" | "TestEntity";

// --- Serialization

export interface EntitySerializedData {
    name: EntityName;
}

// --- Base entity class

export interface EntityParams {
    manager: EntityManager;
    x?: number;
    y?: number;
}

export abstract class Entity {
    abstract name: EntityName;
    abstract moveable: boolean;
    /** Width of the bounding box containing the rendered entity. */
    abstract width: number;
    /** Height of the bounding box containing the rendered entity. */
    abstract height: number;

    x: number = 0;
    y: number = 0;

    /** Auto-generated by the Entity Manager */
    id: number = -1;

    manager: EntityManager;

    constructor(manager: EntityManager) {
        this.manager = manager;
        this.manager.addEntity(this);
    }

    /**
     * Render the entity using the canvas object provided. Assumes scale and
     * translation have been set.
     */
    abstract render(canvas: Canvas): void;

    containsPoint(point: Point): boolean {
        return (
            this.x - this.width / 2 <= point.x &&
            point.x <= this.x + this.width / 2 &&
            this.y - this.height / 2 <= point.y &&
            point.y <= this.y + this.height / 2
        );
    }

    /**
     * Check if the bounding box of this entity intersects with a
     * given rectangle represented by two diagonal points.
     *
     * TODO: Preprocess the parameters so you don't have to max() and min() every time
     */
    intersects(p1: Point, p2: Point): boolean {
        // Rectangle A
        const rAx1 = this.x - this.width / 2;
        const rAx2 = this.x + this.width / 2;
        const rAy1 = this.y - this.height / 2;
        const rAy2 = this.y + this.height / 2;

        // Rectangle B
        const rBx1 = Math.min(p1.x, p2.x);
        const rBx2 = Math.max(p1.x, p2.x);
        const rBy1 = Math.min(p1.y, p2.y);
        const rBy2 = Math.max(p1.y, p2.y);

        // https://stackoverflow.com/a/306332/8089674
        // modified because y increases downwards
        return rAx1 < rBx2 && rAx2 > rBx1 && rAy1 < rBy2 && rAy2 > rBy1;
    }
}

export class EntityManager {
    entities: Entity[] = [];
    /** Functionally similar to `this.entities.length` */
    lastEntityId: number = 0;

    private createEntityId(): number {
        return this.lastEntityId++;
    }

    addEntity(entity: Entity) {
        this.entities.push(entity);
    }

    registerEntity(entity: Entity) {
        entity.id = this.createEntityId();
        this.addEntity(entity);
    }

    getEntity(id: number): Entity {
        return this.entities[id];
    }

    getActiveEntities(): Entity[] {
        return this.entities;
    }

    getEntitiesContaining(point: Point): Entity[] {
        const entities = this.getActiveEntities();
        return entities.filter((entity) => entity.containsPoint(point));
    }

    getEntitiesIntersecting(p1: Point, p2: Point): Entity[] {
        const entities = this.getActiveEntities();
        return entities.filter((entity) => entity.intersects(p1, p2));
    }

    // --- Static Methods

    static load(totalEntityData: EntitySerializedData[]) {
        totalEntityData.forEach((entityData) => {
            throw new Error(
                `Entity type '${entityData.name}' loading has not been implemented.`,
            );
        });
    }
}

// --- Entity Implementations
